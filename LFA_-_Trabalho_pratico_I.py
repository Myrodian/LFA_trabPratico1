# -*- coding: utf-8 -*-
"""LFATP - LFA trabalho pratico I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LN5ycVh9GrOElA06-idKpbCQXQZ1xF4e
"""

import pickle as pk
import os


class AutomatoFD:
    def __init__(self, Alfabeto):
        Alfabeto = str(Alfabeto)
        self.estados = set()
        self.alfabeto = Alfabeto
        self.transicoes = dict()
        self.inicial = None
        self.finais = set()

    def limpaAfd(self):

        self.__deuErro = False
        self.__estadoAtual = self.inicial

    def criaEstado(self, id, inicial=False, final=False):

        id = int(id)
        if id in self.estados:
            return False
        self.estados = self.estados.union({id})
        if inicial:
            self.inicial = id
        if final:
            self.finais = self.finais.union({id})
        return True

    def criaTransicao(self, origem, destino, simbolo):

        origem = int(origem)
        destino = int(destino)
        simbolo = str(simbolo)
        if not origem in self.estados:
            return False
        if not destino in self.estados:
            return False
        if len(simbolo) != 1 or not simbolo in self.alfabeto:
            return False
        self.transicoes[(origem, simbolo)] = destino
        return True

    def mudaEstadoInicial(self, id):
        if not id in self.estados:
            return
        self.inicial = id

    def mudaEstadoFinal(self, id, final):

        if not id in self.estados:
            return
        if final:
            self.finais = self.finais.union({id})
        else:
            self.finais = self.finais.difference({id})

    def move(self, cadeia):

        for simbolo in cadeia:
            if not simbolo in self.alfabeto:
                self.__deuErro = True
                break
            if (self.__estadoAtual, simbolo) in self.transicoes.keys():
                novoEstado = self.transicoes[(self.__estadoAtual, simbolo)]
                self.__estadoAtual = novoEstado
            else:
                self.__deuErro = True
                break
        return self.__estadoAtual

    def deuErro(self):
        return self.__deuErro

    def estadoAtual(self):
        return self.__estadoAtual

    def estadoFinal(self, id):
        return id in self.finais

    def __str__(self):

        s = 'AFD(E, A, T, i, F): \n'
        s += '  E = { '
        for e in self.estados:
            s += '{}, '.format(str(e))
        s += '} \n'
        s += '  A = { '
        for a in self.alfabeto:
            s += '{}, '.format(a)
        s += '} \n'
        s += '  T = { '
        for (e, a) in self.transicoes.keys():
            d = self.transicoes[(e, a)]
            s += "({}, '{}')-->{},".format(e, a, d)
        s += '} \n'
        s += '  i = {} \n'.format(self.inicial)
        s += '  F = { '
        for e in self.finais:
            s += '{}, '.format(str(e))
        s += '}'
        return s

    def encontraArquivoAutomato(nomeArquivo):
        diretorioAtual = os.getcwd()
        caminhoCompleto = os.path.join(diretorioAtual, nomeArquivo)
        return caminhoCompleto

    def salvaAutomato(automato, nomeArquivo):
        with open(nomeArquivo, 'wb') as arquivo:
            pk.dump(automato, arquivo)
        caminhoCompleto = AutomatoFD.encontraArquivoAutomato(nomeArquivo)
        print(f"AutomatoFD salvo em '{caminhoCompleto}' com sucesso.")

    def carregaAutomato(nomeArquivo):
        with open(nomeArquivo, 'rb') as arquivo:
            automato_carregado = pk.load(arquivo)
        return automato_carregado

    def clonaAutomato(automatoOriginal):
        novoAutomato = AutomatoFD(automatoOriginal.alfabeto)
        novoAutomato.estados = automatoOriginal.estados
        novoAutomato.transicoes = automatoOriginal.transicoes
        novoAutomato.inicial = automatoOriginal.inicial
        novoAutomato.finais = automatoOriginal.finais
        return novoAutomato

    def equivalenciaEstados(self):
        matriz_equivalencia = []  # Inicialize uma lista para representar a matriz

        for estado1 in self.estados:
            for estado2 in self.estados:
                if estado1 > estado2:
                    if testa_equivalencia(self, estado1, estado2):
                        nova_linha = [estado1, estado2]  # Crie uma nova lista representando uma linha
                        matriz_equivalencia.append(nova_linha)  # Adicione a nova linha Ã  matriz

        return matriz_equivalencia  # Retorna a matriz de pares equivalentes

def obter_destino(self, origem, simbolo):
    if (origem, simbolo) in self.transicoes:
        return self.transicoes[(origem, simbolo)]
    else:
        return None

def testa_equivalencia(self, estado1, estado2):
    if(estado1 == obter_destino(self, estado2, 'b')):
         return False
    if (estado1 in self.finais and estado2 not in self.finais) or (
            estado1 not in self.finais and estado2 in self.finais):
        return False
    else:
        if (obter_destino(self, estado1, 'a') == obter_destino(self, estado2, 'a')) and (
                obter_destino(self, estado1, 'b') == obter_destino(self, estado2, 'b')):
            return True
        else:
            if (obter_destino(self, estado1, 'a') != obter_destino(self, estado2, 'a')) and (
                    obter_destino(self, estado1, 'b') != obter_destino(self, estado2, 'b')):
                if(estado1 != obter_destino(self, estado2, 'a') and (estado2 != obter_destino(self, estado1,'b'))):
                    if not (testa_equivalencia(self, obter_destino(self, estado1, 'a'), obter_destino(self, estado2, 'a'))):
                        return False
                    else:
                        return testa_equivalencia(self, obter_destino(self, estado1, 'b'), obter_destino(self, estado2, 'b'))
                else:
                    return testa_equivalencia(self, obter_destino(self, estado1, 'b'),obter_destino(self, estado2, 'b'))
            else:
                if (obter_destino(self, estado1, 'a') != obter_destino(self, estado2, 'a')):
                    return testa_equivalencia(self, obter_destino(self, estado1, 'a'),
                                              obter_destino(self, estado2, 'a'))
                else:
                    return testa_equivalencia(self, obter_destino(self, estado1, 'b'),
                                              obter_destino(self, estado2, 'b'))
if __name__ == '__main__':
    afd = AutomatoFD('ab')
    afdSecundario = AutomatoFD('ab')

    for i in range(1, 5):
        afd.criaEstado(i)
    afd.mudaEstadoInicial(1)
    afd.mudaEstadoFinal(2, True)
    afd.criaTransicao(1, 3, 'a')
    afd.criaTransicao(1, 2, 'b')
    afd.criaTransicao(2, 1, 'a')
    afd.criaTransicao(2, 2, 'b')
    afd.criaTransicao(3, 3, 'a')
    afd.criaTransicao(3, 2, 'b')
    afd.criaTransicao(4, 3, 'a')
    afd.criaTransicao(4, 2, 'b')

    print("estados equivalentes:",afd.equivalenciaEstados())

    print('automato salvo', afd)
    afd.salvaAutomato('automatoArquivo')

    cadeia = 'abbabaabbbbbba'
    afd.limpaAfd()
    parada = afd.move(cadeia)
    if not afd.deuErro() and afd.estadoFinal(parada):
        print('Aceita cadeia "{}"'.format(cadeia))
    else:
        print('Rejeita cadeia "{}"'.format(cadeia))
