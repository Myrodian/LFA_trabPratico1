# -*- coding: utf-8 -*-
"""LFATP - LFA trabalho pratico I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LN5ycVh9GrOElA06-idKpbCQXQZ1xF4e
"""

import pickle as pk
import os


class AutomatoFD:
    def __init__(self, Alfabeto):
        Alfabeto = str(Alfabeto)
        self.estados = set()
        self.alfabeto = Alfabeto
        self.transicoes = dict()
        self.inicial = None
        self.finais = set()

    def limpaAfd(self):

        self.__deuErro = False
        self.__estadoAtual = self.inicial

    def criaEstado(self, id, inicial=False, final=False):

        id = int(id)
        if id in self.estados:
            return False
        self.estados = self.estados.union({id})
        if inicial:
            self.inicial = id
        if final:
            self.finais = self.finais.union({id})
        return True

    def criaTransicao(self, origem, destino, simbolo):

        origem = int(origem)
        destino = int(destino)
        simbolo = str(simbolo)
        if not origem in self.estados:
            return False
        if not destino in self.estados:
            return False
        if len(simbolo) != 1 or not simbolo in self.alfabeto:
            return False
        self.transicoes[(origem, simbolo)] = destino
        return True

    def mudaEstadoInicial(self, id):
        if not id in self.estados:
            return
        self.inicial = id

    def mudaEstadoFinal(self, id, final):

        if not id in self.estados:
            return
        if final:
            self.finais = self.finais.union({id})
        else:
            self.finais = self.finais.difference({id})

    def move(self, cadeia):

        for simbolo in cadeia:
            if not simbolo in self.alfabeto:
                self.__deuErro = True
                break
            if (self.__estadoAtual, simbolo) in self.transicoes.keys():
                novoEstado = self.transicoes[(self.__estadoAtual, simbolo)]
                self.__estadoAtual = novoEstado
            else:
                self.__deuErro = True
                break
        return self.__estadoAtual

    def deuErro(self):
        return self.__deuErro

    def estadoAtual(self):
        return self.__estadoAtual

    def estadoFinal(self, id):
        return id in self.finais

    def __str__(self):

        s = 'AFD(E, A, T, i, F): \n'
        s += '  E = { '
        for e in self.estados:
            s += '{}, '.format(str(e))
        s += '} \n'
        s += '  A = { '
        for a in self.alfabeto:
            s += '{}, '.format(a)
        s += '} \n'
        s += '  T = { '
        for (e, a) in self.transicoes.keys():
            d = self.transicoes[(e, a)]
            s += "({}, '{}')-->{},".format(e, a, d)
        s += '} \n'
        s += '  i = {} \n'.format(self.inicial)
        s += '  F = { '
        for e in self.finais:
            s += '{}, '.format(str(e))
        s += '}'
        return s

    def encontraArquivoAutomato(nomeArquivo):
        diretorioAtual = os.getcwd()
        caminhoCompleto = os.path.join(diretorioAtual, nomeArquivo)
        return caminhoCompleto

    def salvaAutomato(automato, nomeArquivo):
        with open(nomeArquivo, 'wb') as arquivo:
            pk.dump(automato, arquivo)
        caminhoCompleto = AutomatoFD.encontraArquivoAutomato(nomeArquivo)
        print(f"AutomatoFD salvo em '{caminhoCompleto}' com sucesso.")

    def carregaAutomato(nomeArquivo):
        with open(nomeArquivo, 'rb') as arquivo:
            automato_carregado = pk.load(arquivo)
        return automato_carregado

    def clonaAutomato(automatoOriginal):
        novoAutomato = AutomatoFD(automatoOriginal.alfabeto)
        novoAutomato.estados = automatoOriginal.estados
        novoAutomato.transicoes = automatoOriginal.transicoes
        novoAutomato.inicial = automatoOriginal.inicial
        novoAutomato.finais = automatoOriginal.finais
        return novoAutomato

    def equivalenciaEstados(self):
        matriz_equivalencia = []

        for estado1 in self.estados:
            for estado2 in self.estados:
                if estado1 > estado2:
                    if testa_equivalencia(self, estado1, estado2):
                        nova_linha = [estado1, estado2]
                        matriz_equivalencia.append(nova_linha)

        return matriz_equivalencia


def obter_destino(self, origem, simbolo):
    if (origem, simbolo) in self.transicoes:
        return self.transicoes[(origem, simbolo)]
    else:
        return None


def testa_equivalencia(self, estado1, estado2):
    for simbolo in self.alfabeto:
        if estado1 == obter_destino(self, estado2, simbolo) and (estado2 == obter_destino(self, estado1, simbolo)):
            return False
        if (estado1 in self.finais and estado2 not in self.finais) or (
                estado1 not in self.finais and estado2 in self.finais):
            return False
        else:
            if obter_destino(self, estado1, simbolo) == obter_destino(self, estado2, simbolo):
                return True
            else:
                if obter_destino(self, estado1, simbolo) != obter_destino(self, estado2, simbolo):
                    if not (testa_equivalencia(self, obter_destino(self, estado1, simbolo),
                                               obter_destino(self, estado2, simbolo))):
                        return False
                    else:
                        return testa_equivalencia(self, obter_destino(self, estado1, simbolo),
                                                  obter_destino(self, estado2, simbolo))
                else:
                    if obter_destino(self, estado1, simbolo) != obter_destino(self, estado2, simbolo):
                        return testa_equivalencia(self, obter_destino(self, estado1, simbolo),
                                                  obter_destino(self, estado2, simbolo))
                    else:
                        return testa_equivalencia(self, obter_destino(self, estado1, simbolo),
                                                  obter_destino(self, estado2, simbolo))


def UniaoAutomatos(automato1, automato2):
    print(automato1.estados)
    print(automato2.estados)
    qtd_estados1 = len(automato1.estados)
    qtd_estados2 = len(automato2.estados)
    total_estados = qtd_estados2 + qtd_estados1 + 1

    alfabeto = automato1.alfabeto
    for simbolo in automato2.alfabeto:
        if simbolo not in alfabeto:
            alfabeto += simbolo

    automato_concatenado = AutomatoFD(alfabeto)

    for i in range(1, total_estados):
        automato_concatenado.criaEstado(i)
    automato_concatenado.mudaEstadoInicial(1)

    for estado in range(1, qtd_estados1 + 1):
        for simbolo in automato1.alfabeto:
            automato_concatenado.criaTransicao(estado, obter_destino(automato1, estado, simbolo), simbolo)
    for estado in range(1, qtd_estados2 + 1):
        for simbolo in automato2.alfabeto:
            automato_concatenado.criaTransicao(estado + qtd_estados1, obter_destino(automato2, estado, simbolo), simbolo)

    automato_concatenado.finais = automato1.finais.union(automato2.finais)


    if testa_equivalencia(automato_concatenado, automato1.inicial, automato1.inicial + qtd_estados1):
        print("Os automatos são equivalentes!")
        automato_concatenado.inicial = automato1.inicial
    else:
        print("Os automatos NÃO são equivalentes!")
    return automato_concatenado


# automato_concatenado = automato1.estados.union(automato2.estados.union())
# print(automato_concatenado.estados)
if __name__ == '__main__':
    afd = AutomatoFD('ab')
    afdSecundario = AutomatoFD('ab')

    for i in range(1, 4):
        afd.criaEstado(i)
    afd.mudaEstadoInicial(1)

    # Define os estados finais
    afd.mudaEstadoFinal(2, True)

    # Cria as transições
    afd.criaTransicao(1, 3, 'a')
    afd.criaTransicao(1, 2, 'b')
    afd.criaTransicao(2, 1, 'a')
    afd.criaTransicao(2, 2, 'b')
    afd.criaTransicao(3, 3, 'a')
    afd.criaTransicao(3, 2, 'b')

    for i in range(1, 4):
        afdSecundario.criaEstado(i)
    afdSecundario.mudaEstadoInicial(1)

    # Define os estados finais
    afdSecundario.mudaEstadoFinal(2, True)
    afdSecundario.criaTransicao(1, 3, 'a')
    afdSecundario.criaTransicao(1, 2, 'b')
    afdSecundario.criaTransicao(2, 1, 'a')
    afdSecundario.criaTransicao(2, 2, 'b')
    afdSecundario.criaTransicao(3, 3, 'a')
    afdSecundario.criaTransicao(3, 2, 'b')

    #Eprint(afd)
    #print(afdSecundario)
    #print("estados equivalentes:", afd.equivalenciaEstados())
    concatenado = UniaoAutomatos(afd, afdSecundario)
    print(concatenado)
    #print("O que esperar disso aqui?:", concatenado.equivalenciaEstados())


    # print('automato salvo', afd)
    # afd.salvaAutomato('automatoArquivo')

    cadeia = 'abbabaabbbbbba'
    afd.limpaAfd()
    parada = afd.move(cadeia)
    if not afd.deuErro() and afd.estadoFinal(parada):
        print('Aceita cadeia "{}"'.format(cadeia))
    else:
        print('Rejeita cadeia "{}"'.format(cadeia))
