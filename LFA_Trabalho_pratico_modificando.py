# -*- coding: utf-8 -*-
"""LFATP - LFA trabalho pratico I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LN5ycVh9GrOElA06-idKpbCQXQZ1xF4e
"""

import pickle as pk
import os
from enum import Enum


class EstadosComparacao(Enum):
    EQUIVALENTE = 1
    NAOEQUIVALENTE = 2
    PENDENTE = 3


class AutomatoFD:
    def __init__(self, Alfabeto):
        Alfabeto = str(Alfabeto)
        self.estados = set()
        self.alfabeto = Alfabeto
        self.transicoes = dict()
        self.inicial = None
        self.finais = set()


    def limpaAfd(self):

        self.__deuErro = False
        self.__estadoAtual = self.inicial

    def criaEstado(self, id, inicial=False, final=False):

        id = int(id)
        if id in self.estados:
            return False
        self.estados = self.estados.union({id})
        if inicial:
            self.inicial = id
        if final:
            self.finais = self.finais.union({id})
        return True

    def criaTransicao(self, origem, destino, simbolo):

        origem = int(origem)
        destino = int(destino)
        simbolo = str(simbolo)
        if not origem in self.estados:
            return False
        if not destino in self.estados:
            return False
        if len(simbolo) != 1 or not simbolo in self.alfabeto:
            return False
        self.transicoes[(origem, simbolo)] = destino
        return True

    def mudaEstadoInicial(self, id):
        if not id in self.estados:
            return
        self.inicial = id

    def mudaEstadoFinal(self, id, final):

        if not id in self.estados:
            return
        if final:
            self.finais = self.finais.union({id})
        else:
            self.finais = self.finais.difference({id})

    def move(self, cadeia):

        for simbolo in cadeia:
            if not simbolo in self.alfabeto:
                self.__deuErro = True
                break
            if (self.__estadoAtual, simbolo) in self.transicoes.keys():
                novoEstado = self.transicoes[(self.__estadoAtual, simbolo)]
                self.__estadoAtual = novoEstado
            else:
                self.__deuErro = True
                break
        return self.__estadoAtual

    def deuErro(self):
        return self.__deuErro

    def estadoAtual(self):
        return self.__estadoAtual

    def estadoFinal(self, id):
        return id in self.finais

    def __str__(self):

        s = 'AFD(E, A, T, i, F): \n'
        s += '  E = { '
        for e in self.estados:
            s += '{}, '.format(str(e))
        s += '} \n'
        s += '  A = { '
        for a in self.alfabeto:
            s += '{}, '.format(a)
        s += '} \n'
        s += '  T = { '
        for (e, a) in self.transicoes.keys():
            d = self.transicoes[(e, a)]
            s += "({}, '{}')-->{},".format(e, a, d)
        s += '} \n'
        s += '  i = {} \n'.format(self.inicial)
        s += '  F = { '
        for e in self.finais:
            s += '{}, '.format(str(e))
        s += '}'
        return s

    def encontraArquivoAutomato(nomeArquivo):
        diretorioAtual = os.getcwd()
        caminhoCompleto = os.path.join(diretorioAtual, nomeArquivo)
        return caminhoCompleto

    def salvaAutomato(automato, nomeArquivo):
        with open(nomeArquivo, 'wb') as arquivo:
            pk.dump(automato, arquivo)
        caminhoCompleto = AutomatoFD.encontraArquivoAutomato(nomeArquivo)
        print(f"AutomatoFD salvo em '{caminhoCompleto}' com sucesso.")

    def carregaAutomato(nomeArquivo):
        with open(nomeArquivo, 'rb') as arquivo:
            automato_carregado = pk.load(arquivo)
        return automato_carregado

    def clonaAutomato(automatoOriginal):
        novoAutomato = AutomatoFD(automatoOriginal.alfabeto)
        novoAutomato.estados = automatoOriginal.estados
        novoAutomato.transicoes = automatoOriginal.transicoes
        novoAutomato.inicial = automatoOriginal.inicial
        novoAutomato.finais = automatoOriginal.finais
        return novoAutomato

    def removerTransicoes(self, estado):
        transicoes_a_remover = []
        for transicao, destino in self.transicoes.items():
            origem, simbolo = transicao
            if origem == estado or destino == estado:
                transicoes_a_remover.append(transicao)
        for transicao in transicoes_a_remover:
            del self.transicoes[transicao]

    def minimizaAfd(self):
        mat_equivalentes = self.equivalenciaEstados()
        for par in mat_equivalentes:
            estado1 = par[0]
            estado2 = par[1]
            estadoexcluir = max(estado1, estado2)
            estadosalvar = min(estado1, estado2)
            for simbolo in self.alfabeto:
                for estados in self.estados:
                    if estadoexcluir == obter_destino(self, estados, simbolo):
                        self.criaTransicao(estados, estadosalvar, simbolo)

            for final in self.finais:
                if estadoexcluir == final:
                    self.mudaEstadoFinal(estadoexcluir, False)

            self.estados.discard(estadoexcluir)
            self.removerTransicoes(estadoexcluir)

    def __equivalenciaEstados(self):
        matriz_equivalencia = []
        ec = EstadosComparacao
        for estado1 in self.estados:
            for estado2 in self.estados:
                if estado1 > estado2:
                    if estado1 in self.finais and estado2 not in self.finais:
                        matriz_equivalencia[estado1][estado2].append(ec.NAOEQUIVALENTE)
                    elif estado2 in self.finais and estado1 not in self.finais:
                        matriz_equivalencia[estado1][estado2].append(ec.NAOEQUIVALENTE)
                    else:
                        matriz_equivalencia[estado1][estado2].append(None)

        return matriz_equivalencia

    def testa_equivalencia(self):
        matriz_equivalencia = self.__equivalenciaEstados()
        ec = EstadosComparacao
        pendente = True
        mudou = False
        while pendente and not mudou:
            mudou = True
            pendente = True
            for estado1 in self.estados:
                equivalente = True
                for estado2 in range(0, estado1):
                    if matriz_equivalencia[estado1][estado2] is None or matriz_equivalencia[estado1][estado2] == ec.NAOEQUIVALENTE:

                        pendente = False
                        for simbolo in self.alfabeto:
                            if (estado1 + 1, simbolo) not in self.transicoes or (
                                    estado2 + 1, simbolo) not in self.transicoes:
                                equivalente = False
                                matriz_equivalencia[estado1][estado2] = ec.NAOEQUIVALENTE
                                break

                            estado1 = obter_destino(self, estado1, simbolo)
                            estado2 = obter_destino(self, estado2, simbolo)

                            if estado2 > estado1:
                                estado2, estado1 = estado1, estado2

                            if estado1 != estado2 and matriz_equivalencia[estado1][estado2] is ec.NAOEQUIVALENTE:
                                equivalente = False
                                mudou = False
                                matriz_equivalencia[estado1][estado2] = ec.NAOEQUIVALENTE
                                break
                            elif estado1 != estado2 and (
                                    matriz_equivalencia[estado1][estado2] is None or matriz_equivalencia[estado1][
                                estado2] == ec.PENDENTE):
                                equivalente = False
                                mudou = False
                                matriz_equivalencia[estado1][estado2] = ec.PENDENTE
                                break
                        if equivalente:
                            mudou = False
                            matriz_equivalencia[estado1][estado2] = ec.EQUIVALENTE

                            nova_linha = [estado1, estado2]
                            matriz_equivalencia.append(nova_linha)

        return matriz_equivalencia


def obter_destino(self, origem, simbolo):
    if (origem, simbolo) in self.transicoes:
        return self.transicoes[(origem, simbolo)]
    else:
        return None


def uneAlfabeto(alfabeto1, alfabeto2):
    alfabeto = alfabeto1
    for simbolo in alfabeto2:
        if simbolo not in alfabeto:
            alfabeto += simbolo
    return alfabeto


def UniaoAutomatos(automato1, automato2):
    qtd_estados1 = len(automato1.estados)
    qtd_estados2 = len(automato2.estados)
    total_estados = qtd_estados2 + qtd_estados1
    automato_concatenado = AutomatoFD((uneAlfabeto(automato1.alfabeto, automato2.alfabeto)))
    for i in range(1, total_estados):
        automato_concatenado.criaEstado(i)
    automato_concatenado.mudaEstadoInicial(1)

    for estado in range(1, qtd_estados1 + 1):
        for simbolo in automato1.alfabeto:
            automato_concatenado.criaTransicao(estado, obter_destino(automato1, estado, simbolo), simbolo)

    for estado in range(1, qtd_estados2):
        for simbolo in automato2.alfabeto:
            automato_concatenado.criaTransicao(estado + qtd_estados1, obter_destino(automato2, estado, simbolo),
                                               simbolo)

    automato_concatenado.finais = automato1.finais.union(automato2.finais)

    return automato_concatenado


def automatosEquivalentes(automato1, automato2):
    automato_concatenado = UniaoAutomatos(automato1, automato2)

    if testa_equivalencia(automato_concatenado, automato1.inicial, automato1.inicial + len(automato1.estados)):
        print("Os automatos são equivalentes!")
        automato_concatenado.inicial = automato1.inicial
    else:
        print("Os automatos NÃO são equivalentes!")
    return automato_concatenado


# def intercessaoAutomato(automato1, automato2):

def encontraParNaMatriz(matriz, valor1, valor2):
    for indice, par in enumerate(matriz):
        if par == [valor1, valor2]:
            return indice
    return None  # Retorna None se o par ordenado não for encontrado na matriz


def multiplicaAutomato(automato1, automato2):
    num_estados = len(automato1.estados) * len(automato2.estados)
    conjunto_uniao_estados = [[x, y] for x in automato1.estados for y in automato2.estados]
    afd = AutomatoFD(uneAlfabeto(automato1.alfabeto, automato2.alfabeto))
    # print('Estados de 1: ', automato1.estados)
    # print('Estados de 2: ', automato2.estados)
    # print('cnoj_uniao: ',conjunto_uniao_estados)
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        afd.criaEstado(estado + 1)
    estado = 0
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        estadoDoAfd1 = conjunto_uniao_estados[estado][0]
        estadoDoAfd2 = conjunto_uniao_estados[estado][1]
        if (estadoDoAfd1 == automato1.inicial and estadoDoAfd2 == automato2.inicial):
            afd.inicial = (encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1)
            # print('este par é o inicio: ', estadoDoAfd1, ';', estadoDoAfd2)
        if ((estadoDoAfd1 in automato1.finais) or (estadoDoAfd2 in automato2.finais)):
            afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)
            # print('este par é dos finais: ', estadoDoAfd1, ';', estadoDoAfd2)
        for simbolo in automato1.alfabeto:
            destinoTransicao1 = obter_destino(automato1, estadoDoAfd1, simbolo)
            destinoTransicao2 = obter_destino(automato2, estadoDoAfd2, simbolo)
            afd.criaTransicao(estado + 1,
                              (encontraParNaMatriz(conjunto_uniao_estados, destinoTransicao1, destinoTransicao2) + 1),
                              simbolo)
    return afd


def automatoIntercesao(automato1, automato2):
    num_estados = len(automato1.estados) * len(automato2.estados)
    conjunto_uniao_estados = [[x, y] for x in automato1.estados for y in automato2.estados]
    afd = AutomatoFD(uneAlfabeto(automato1.alfabeto, automato2.alfabeto))
    # print('Estados de 1: ', automato1.estados)
    # print('Estados de 2: ', automato2.estados)
    # print('cnoj_uniao: ',conjunto_uniao_estados)
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        afd.criaEstado(estado + 1)
    estado = 0
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        estadoDoAfd1 = conjunto_uniao_estados[estado][0]
        estadoDoAfd2 = conjunto_uniao_estados[estado][1]
        if (estadoDoAfd1 == automato1.inicial and estadoDoAfd2 == automato2.inicial):
            afd.inicial = (encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1)
            # print('este par é o inicio: ', estadoDoAfd1, ';', estadoDoAfd2)
        if ((estadoDoAfd1 in automato1.finais) and (estadoDoAfd2 in automato2.finais)):
            afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)
            # print('este par é dos finais: ', estadoDoAfd1, ';', estadoDoAfd2)
        for simbolo in automato1.alfabeto:
            destinoTransicao1 = obter_destino(automato1, estadoDoAfd1, simbolo)
            destinoTransicao2 = obter_destino(automato2, estadoDoAfd2, simbolo)
            afd.criaTransicao(estado + 1,
                              (encontraParNaMatriz(conjunto_uniao_estados, destinoTransicao1, destinoTransicao2) + 1),
                              simbolo)
    return afd


def automatoUniao(automato1, automato2):
    num_estados = len(automato1.estados) * len(automato2.estados)
    conjunto_uniao_estados = [[x, y] for x in automato1.estados for y in automato2.estados]
    afd = AutomatoFD(uneAlfabeto(automato1.alfabeto, automato2.alfabeto))
    # print('Estados de 1: ', automato1.estados)
    # print('Estados de 2: ', automato2.estados)
    # print('cnoj_uniao: ',conjunto_uniao_estados)
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        afd.criaEstado(estado + 1)
    estado = 0
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        estadoDoAfd1 = conjunto_uniao_estados[estado][0]
        estadoDoAfd2 = conjunto_uniao_estados[estado][1]
        if (estadoDoAfd1 == automato1.inicial and estadoDoAfd2 == automato2.inicial):
            afd.inicial = (encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1)
            # print('este par é o inicio: ', estadoDoAfd1, ';', estadoDoAfd2)
        if ((estadoDoAfd1 in automato1.finais) or (estadoDoAfd2 in automato2.finais) and estadoDoAfd1 != estadoDoAfd2):
            afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)
            # print('este par é dos finais: ', estadoDoAfd1, ';', estadoDoAfd2)
        for simbolo in automato1.alfabeto:
            destinoTransicao1 = obter_destino(automato1, estadoDoAfd1, simbolo)
            destinoTransicao2 = obter_destino(automato2, estadoDoAfd2, simbolo)
            afd.criaTransicao(estado + 1,
                              (encontraParNaMatriz(conjunto_uniao_estados, destinoTransicao1, destinoTransicao2) + 1),
                              simbolo)
    return afd


if __name__ == '__main__':

    # afd = AutomatoFD('ab')
    # afdSecundario = AutomatoFD('01')

    # for i in range(1, 4):
    #    afd.criaEstado(i)
    # afd.mudaEstadoInicial(1)

    # Defina o estado final
    # afd.mudaEstadoFinal(2, True)

    # Crie as transições
    # afd.criaTransicao(1, 2, 'a')
    # afd.criaTransicao(2, 3, 'b')
    # afd.criaTransicao(2, 1, 'a')

    afdSecundario = AutomatoFD('ab')
    for i in range(1, 7):
        afdSecundario.criaEstado(i)
    afdSecundario.mudaEstadoInicial(1)

    afdSecundario.mudaEstadoFinal(1, True)
    afdSecundario.mudaEstadoFinal(5, True)
    afdSecundario.mudaEstadoFinal(6, True)

    afdSecundario.criaTransicao(1, 3, 'a')
    afdSecundario.criaTransicao(1, 2, 'b')
    afdSecundario.criaTransicao(2, 2, 'a')
    afdSecundario.criaTransicao(2, 1, 'b')
    afdSecundario.criaTransicao(3, 5, 'a')
    afdSecundario.criaTransicao(3, 6, 'b')
    afdSecundario.criaTransicao(4, 6, 'a')
    afdSecundario.criaTransicao(4, 5, 'b')
    afdSecundario.criaTransicao(5, 4, 'a')
    afdSecundario.criaTransicao(5, 3, 'b')
    afdSecundario.criaTransicao(6, 3, 'a')
    afdSecundario.criaTransicao(6, 4, 'b')

    afdSecundario.testa_equivalencia()
    print('equivalencias:', mat)
    print(afdSecundario)

    #  afdSecundario.minimizaAfd()

    # print(afdSecundario)
    # print("estados equivalentes:", afd.equivalenciaEstados())
    # afdTernario = multiplicaAutomato(afd, afdSecundario)
    # print(afdTernario)
    # multiplicaAutomato(afd, afdSecundario)
    # print('automato ternario: \n\n',automatoTernario)
    # print(concatenado)
    # print("O que esperar disso aqui?:", concatenado.equivalenciaEstados())
    # print(multiplicaAutomato(afd,afdSecundario))
    # print('-----------------------------------------------\\-----------------------------------------------')
    # print(automatoIntercesao(afd,afdSecundario))
    # print('-----------------------------------------------\\-----------------------------------------------')
    # print(automatoUniao(afd,afdSecundario))
    print('-----------------------------------------------\\-----------------------------------------------')
    print(afdSecundario)
    # afd.salvaAutomato('automatoArquivo')

    # automatosEquivalentes(afd, afdSecundario)

    cadeia = 'ababbbba'
    afdSecundario.limpaAfd()
    parada = afdSecundario.move(cadeia)
    if not afdSecundario.deuErro() and afdSecundario.estadoFinal(parada):
        print('Aceita cadeia "{}"'.format(cadeia))
    else:
        print('Rejeita cadeia "{}"'.format(cadeia))
