# -*- coding: utf-8 -*-
"""LFATP - LFA trabalho pratico I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LN5ycVh9GrOElA06-idKpbCQXQZ1xF4e
"""

import pickle as pk
import os
from enum import Enum


class EstadosComparacao(Enum):
    EQUIVALENTE = 1
    NAOEQUIVALENTE = 2
    PENDENTE = 3


class AutomatoFD:
    def __init__(self, Alfabeto):
        Alfabeto = str(Alfabeto)
        self.estados = set()
        self.alfabeto = Alfabeto
        self.transicoes = dict()
        self.inicial = None
        self.finais = set()

    def limpaAfd(self):

        self.__deuErro = False
        self.__estadoAtual = self.inicial

    def criaEstado(self, id, inicial=False, final=False):

        id = int(id)
        if id in self.estados:
            return False
        self.estados = self.estados.union({id})
        if inicial:
            self.inicial = id
        if final:
            self.finais = self.finais.union({id})
        return True

    def criaTransicao(self, origem, destino, simbolo):

        origem = int(origem)
        destino = int(destino)
        simbolo = str(simbolo)
        if not origem in self.estados:
            return False
        if not destino in self.estados:
            return False
        if len(simbolo) != 1 or not simbolo in self.alfabeto:
            return False
        self.transicoes[(origem, simbolo)] = destino
        return True

    def mudaEstadoInicial(self, id):
        if not id in self.estados:
            return
        self.inicial = id

    def mudaEstadoFinal(self, id, final):

        if not id in self.estados:
            return
        if final:
            self.finais = self.finais.union({id})
        else:
            self.finais = self.finais.difference({id})

    def move(self, cadeia):

        for simbolo in cadeia:
            if not simbolo in self.alfabeto:
                self.__deuErro = True
                break
            if (self.__estadoAtual, simbolo) in self.transicoes.keys():
                novoEstado = self.transicoes[(self.__estadoAtual, simbolo)]
                self.__estadoAtual = novoEstado
            else:
                self.__deuErro = True
                break
        return self.__estadoAtual

    def deuErro(self):
        return self.__deuErro

    def estadoAtual(self):
        return self.__estadoAtual

    def estadoFinal(self, id):
        return id in self.finais

    def __str__(self):

        s = 'AFD(E, A, T, i, F): \n'
        s += '  E = { '
        for e in self.estados:
            s += '{}, '.format(str(e))
        s += '} \n'
        s += '  A = { '
        for a in self.alfabeto:
            s += '{}, '.format(a)
        s += '} \n'
        s += '  T = { '
        for (e, a) in self.transicoes.keys():
            d = self.transicoes[(e, a)]
            s += "({}, '{}')-->{},".format(e, a, d)
        s += '} \n'
        s += '  i = {} \n'.format(self.inicial)
        s += '  F = { '
        for e in self.finais:
            s += '{}, '.format(str(e))
        s += '}'
        return s

    def encontraArquivoAutomato(nomeArquivo):
        diretorioAtual = os.getcwd()
        caminhoCompleto = os.path.join(diretorioAtual, nomeArquivo)
        return caminhoCompleto

    def salvaAutomato(automato, nomeArquivo):
        with open(nomeArquivo, 'wb') as arquivo:
            pk.dump(automato, arquivo)
        caminhoCompleto = AutomatoFD.encontraArquivoAutomato(nomeArquivo)
        print(f"AutomatoFD salvo em '{caminhoCompleto}' com sucesso.")

    def carregaAutomato(nomeArquivo):
        with open(nomeArquivo, 'rb') as arquivo:
            automato_carregado = pk.load(arquivo)
        return automato_carregado

    def clonaAutomato(automatoOriginal):
        novoAutomato = AutomatoFD(automatoOriginal.alfabeto)
        novoAutomato.estados = automatoOriginal.estados
        novoAutomato.transicoes = automatoOriginal.transicoes
        novoAutomato.inicial = automatoOriginal.inicial
        novoAutomato.finais = automatoOriginal.finais
        return novoAutomato

    def removerTransicoes(self, estado):
        transicoes_a_remover = []
        for transicao, destino in self.transicoes.items():
            origem, simbolo = transicao
            if origem == estado or destino == estado:
                transicoes_a_remover.append(transicao)
        for transicao in transicoes_a_remover:
            del self.transicoes[transicao]

    def minimizaAfd(self):
        mat_equivalentes = self.testa_equivalencia()
        for par in mat_equivalentes:
            estado1 = par[0]
            estado2 = par[1]
            estadoexcluir = max(estado1, estado2)
            estadosalvar = min(estado1, estado2)
            for simbolo in self.alfabeto:
                for estados in self.estados:
                    if estadoexcluir == obter_destino(self, estados, simbolo):
                        self.criaTransicao(estados, estadosalvar, simbolo)

            for final in self.finais:
                if estadoexcluir == final:
                    self.mudaEstadoFinal(estadoexcluir, False)

            self.estados.discard(estadoexcluir)
            self.removerTransicoes(estadoexcluir)

    def __nao_marcado(self, afd_dict):
        for estado1 in self.estados:
            for estado2 in self.estados:
                if estado1 > estado2:
                    if afd_dict[estado1, estado2] == EstadosComparacao.PENDENTE:
                        afd_dict[estado1, estado2] = EstadosComparacao.EQUIVALENTE

    def __equivalenciaEstados(self):
        afd_dict = dict()
        ec = EstadosComparacao
        for estado1 in self.estados:
            for estado2 in self.estados:
                if estado1 > estado2:
                    if estado1 in self.finais and estado2 not in self.finais:
                        afd_dict[estado1, estado2] = ec.NAOEQUIVALENTE
                    elif estado2 in self.finais and estado1 not in self.finais:
                        afd_dict[estado1, estado2] = ec.NAOEQUIVALENTE
                    else:
                        afd_dict[estado1, estado2] = ec.PENDENTE

        return afd_dict

    def testa_equivalencia(self):
        afd_dict = self.__equivalenciaEstados()
        ec = EstadosComparacao
        pendente = True
        mudou = False
        while pendente and not mudou:
            mudou = True
            pendente = True
            for estado1 in self.estados:
                equivalente = True
                for estado2 in self.estados:
                    if estado1 > estado2:
                        if afd_dict[estado1, estado2] is None or afd_dict[estado1, estado2] == ec.PENDENTE:
                            pendente = False
                            for simbolo in self.alfabeto:
                                if (estado1, simbolo) not in self.transicoes or (
                                        estado2, simbolo) not in self.transicoes:
                                    equivalente = False
                                    afd_dict[estado1, estado2] = ec.NAOEQUIVALENTE
                                    break

                                estado1_proximo = self.transicoes[estado1, simbolo]
                                estado2_proximo = self.transicoes[estado2, simbolo]
                                if estado2_proximo > estado1_proximo:
                                    estado2_proximo, estado1_proximo = estado1_proximo, estado2_proximo

                                if estado1_proximo != estado2_proximo and afd_dict[
                                    estado1_proximo, estado2_proximo] is ec.NAOEQUIVALENTE:
                                    equivalente = False
                                    mudou = False
                                    afd_dict[estado1, estado2] = ec.NAOEQUIVALENTE
                                    break
                                elif estado2_proximo != estado1_proximo and (
                                        afd_dict[estado1_proximo, estado2_proximo] is None or afd_dict[
                                    estado1_proximo, estado2_proximo] == ec.PENDENTE):
                                    equivalente = False
                                    mudou = False
                                    afd_dict[estado1, estado2] = ec.PENDENTE

                            if equivalente:
                                mudou = False
                                afd_dict[estado1, estado2] = ec.EQUIVALENTE

        self.__nao_marcado(afd_dict)
        matriz_equivalencia = []
        for chave, valor in afd_dict.items():
            if valor == EstadosComparacao.EQUIVALENTE:
                matriz_equivalencia.append(chave)
        return matriz_equivalencia

    def afdComplemento(self):
        afd = AutomatoFD(self.alfabeto)
        afd.estados = self.estados
        afd.inicial = self.inicial
        afd.transicoes = self.transicoes
        for estado in self.estados:
            if estado not in self.finais:
                afd.mudaEstadoFinal(estado, True)
        return afd


def obter_destino(self, origem, simbolo):
    if (origem, simbolo) in self.transicoes:
        return self.transicoes[(origem, simbolo)]
    else:
        return None


def uneAlfabeto(alfabeto1, alfabeto2):
    alfabeto = alfabeto1
    for simbolo in alfabeto2:
        if simbolo not in alfabeto:
            alfabeto += simbolo
    return alfabeto


def UniaoAutomatos(automato1, automato2):
    qtd_estados1 = len(automato1.estados)
    qtd_estados2 = len(automato2.estados)
    total_estados = qtd_estados2 + qtd_estados1
    automato_concatenado = AutomatoFD(
        (uneAlfabeto(automato1.alfabeto, automato2.alfabeto)))  # talvez nao da certo por causa do alfabeto

    for i in range(1, total_estados + 1):
        automato_concatenado.criaEstado(i)
    automato_concatenado.mudaEstadoInicial(1)

    automato_concatenado.finais = automato1.finais.union(automato2.finais)

    for estado in range(1, qtd_estados1 + 1):
        for simbolo in automato1.alfabeto:
            destino = obter_destino(automato1, estado, simbolo)
            automato_concatenado.criaTransicao(estado, destino, simbolo)

    for estado in range(1, qtd_estados2 + 1):
        for simbolo in automato2.alfabeto:
            destino = obter_destino(automato2, estado, simbolo)
            automato_concatenado.criaTransicao(estado + qtd_estados1, destino, simbolo)

    return automato_concatenado


def automatosEquivalentes(automato1, automato2):
    automato_concatenado = UniaoAutomatos(automato1, automato2)
    # print(automato_concatenado)
    matriz = automato_concatenado.testa_equivalencia()
    # print(matriz)
    palavra = 'ab'

    automato1.limpaAfd()
    automato2.limpaAfd()
    parada1 = automato1.move(palavra)
    parada2 = automato2.move(palavra)
    if automato1.deuErro() != automato2.deuErro():
        print("não são iguais")
    else:
        print("pode ser que sejam iguais")
        tamanho1 = len(automato1.estados)
        tamanho2 = len(automato2.estados)
    return automato_concatenado


# def intercessaoAutomato(automato1, automato2):

def encontraParNaMatriz(matriz, valor1, valor2):
    for indice, par in enumerate(matriz):
        if par == [valor1, valor2]:
            return indice
    return None  # Retorna None se o par ordenado não for encontrado na matriz


def multiplicaAutomato(automato1, automato2, operacao):
    print(len(automato1.estados))
    print(len(automato2.estados))
    num_estados = len(automato1.estados) * len(automato2.estados)
    print(num_estados)
    estado_erro = num_estados + 1
    conjunto_uniao_estados = [[x, y] for x in automato1.estados for y in automato2.estados]

    afd = AutomatoFD(uneAlfabeto(automato1.alfabeto, automato2.alfabeto))

    # cria estado de erro
    afd.criaEstado(estado_erro)
    for simbolo in afd.alfabeto:
        afd.criaTransicao(estado_erro, estado_erro, simbolo)

    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        afd.criaEstado(estado + 1)

    estado = 0
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)

        estadoDoAfd1 = conjunto_uniao_estados[estado][0]
        estadoDoAfd2 = conjunto_uniao_estados[estado][1]

        if (estadoDoAfd1 == automato1.inicial and estadoDoAfd2 == automato2.inicial):
            afd.inicial = (encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1)
            # print('este par é o inicio: ', estadoDoAfd1, ';', estadoDoAfd2)

        if (operacao == 1):  # uniao

            if (estadoDoAfd1 in automato1.finais or estadoDoAfd2 in automato2.finais):
                afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)

        elif (operacao == 2):  # intercessao

            if (estadoDoAfd1 in automato1.finais and estadoDoAfd2 in automato2.finais):
                afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)
        elif (operacao == 3):  # intercessao

            if (estadoDoAfd1 in automato1.finais and estadoDoAfd2 not in automato2.finais):
                afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)

        for simbolo in automato1.alfabeto:

            destinoTransicao1 = obter_destino(automato1, estadoDoAfd1, simbolo)
            destinoTransicao2 = obter_destino(automato2, estadoDoAfd2, simbolo)
            destino = encontraParNaMatriz(conjunto_uniao_estados, destinoTransicao1, destinoTransicao2)
            if (destino != None):
                afd.criaTransicao(estado + 1, destino + 1, simbolo)
            else:
                afd.criaTransicao(estado + 1, estado_erro, simbolo)
    return afd


def automatoIntercesao(automato1, automato2):
    num_estados = len(automato1.estados) * len(automato2.estados)
    conjunto_uniao_estados = [[x, y] for x in automato1.estados for y in automato2.estados]
    afd = AutomatoFD(uneAlfabeto(automato1.alfabeto, automato2.alfabeto))
    # print('Estados de 1: ', automato1.estados)
    # print('Estados de 2: ', automato2.estados)
    # print('cnoj_uniao: ',conjunto_uniao_estados)
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        afd.criaEstado(estado + 1)
    estado = 0
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        estadoDoAfd1 = conjunto_uniao_estados[estado][0]
        estadoDoAfd2 = conjunto_uniao_estados[estado][1]
        if (estadoDoAfd1 == automato1.inicial and estadoDoAfd2 == automato2.inicial):
            afd.inicial = (encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1)
            # print('este par é o inicio: ', estadoDoAfd1, ';', estadoDoAfd2)
        if ((estadoDoAfd1 in automato1.finais) and (estadoDoAfd2 in automato2.finais)):
            afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)
            # print('este par é dos finais: ', estadoDoAfd1, ';', estadoDoAfd2)
        for simbolo in automato1.alfabeto:
            destinoTransicao1 = obter_destino(automato1, estadoDoAfd1, simbolo)
            destinoTransicao2 = obter_destino(automato2, estadoDoAfd2, simbolo)
            afd.criaTransicao(estado + 1,
                              (encontraParNaMatriz(conjunto_uniao_estados, destinoTransicao1, destinoTransicao2) + 1),
                              simbolo)
    return afd


def automatoUniao(automato1, automato2):
    num_estados = len(automato1.estados) * len(automato2.estados)
    conjunto_uniao_estados = [[x, y] for x in automato1.estados for y in automato2.estados]
    afd = AutomatoFD(uneAlfabeto(automato1.alfabeto, automato2.alfabeto))
    # print('Estados de 1: ', automato1.estados)
    # print('Estados de 2: ', automato2.estados)
    # print('cnoj_uniao: ',conjunto_uniao_estados)
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        afd.criaEstado(estado + 1)
    estado = 0
    for estado in range(num_estados):  # para um estado de conj_uniao, 0 = automato1, 1 = automato2
        # print('estado: ',estado)
        estadoDoAfd1 = conjunto_uniao_estados[estado][0]
        estadoDoAfd2 = conjunto_uniao_estados[estado][1]
        if (estadoDoAfd1 == automato1.inicial and estadoDoAfd2 == automato2.inicial):
            afd.inicial = (encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1)
            # print('este par é o inicio: ', estadoDoAfd1, ';', estadoDoAfd2)
        if ((estadoDoAfd1 in automato1.finais) or (estadoDoAfd2 in automato2.finais) and estadoDoAfd1 != estadoDoAfd2):
            afd.mudaEstadoFinal(encontraParNaMatriz(conjunto_uniao_estados, estadoDoAfd1, estadoDoAfd2) + 1, True)
            # print('este par é dos finais: ', estadoDoAfd1, ';', estadoDoAfd2)
        for simbolo in automato1.alfabeto:
            destinoTransicao1 = obter_destino(automato1, estadoDoAfd1, simbolo)
            destinoTransicao2 = obter_destino(automato2, estadoDoAfd2, simbolo)
            afd.criaTransicao(estado + 1,
                              (encontraParNaMatriz(conjunto_uniao_estados, destinoTransicao1, destinoTransicao2) + 1),
                              simbolo)
    return afd


if __name__ == '__main__':

    afd = AutomatoFD('ab')
    for i in range(1, 4):
        afd.criaEstado(i)
    afd.mudaEstadoInicial(1)

    # Defina o estado final
    afd.mudaEstadoFinal(2, True)

    # Crie as transições
    afd.criaTransicao(1, 3, 'a')
    afd.criaTransicao(1, 2, 'b')
    afd.criaTransicao(2, 1, 'a')
    afd.criaTransicao(2, 2, 'b')
    afd.criaTransicao(3, 3, 'a')
    afd.criaTransicao(3, 2, 'b')
    print("Automato 1:\n", afd)
    print('-----------------------------------------------\\-----------------------------------------------')
    afdSecundario = AutomatoFD('ab')
    for i in range(1, 7):
        afdSecundario.criaEstado(i)
    afdSecundario.mudaEstadoInicial(1)

    afdSecundario.mudaEstadoFinal(1, True)
    afdSecundario.mudaEstadoFinal(5, True)
    afdSecundario.mudaEstadoFinal(6, True)

    afdSecundario.criaTransicao(1, 3, 'a')
    afdSecundario.criaTransicao(1, 2, 'b')
    afdSecundario.criaTransicao(2, 2, 'a')
    afdSecundario.criaTransicao(2, 1, 'b')
    afdSecundario.criaTransicao(3, 5, 'a')
    afdSecundario.criaTransicao(3, 6, 'b')
    afdSecundario.criaTransicao(4, 6, 'a')
    afdSecundario.criaTransicao(4, 5, 'b')
    afdSecundario.criaTransicao(5, 4, 'a')
    afdSecundario.criaTransicao(5, 3, 'b')
    afdSecundario.criaTransicao(6, 3, 'a')
    afdSecundario.criaTransicao(6, 4, 'b')
    print("Automato 2:\n", afdSecundario)
    # mat = afdSecundario.testa_equivalencia()
    # print("matriz de equivalencia:", mat)
    # print(afdSecundario)
    # print('-----------------------------------------------\\-----------------------------------------------')
    # ------------------------------------------------
    # MINIMIZAÇÃO
    # afdSecundario.minimizaAfd()
    # print(afdSecundario)
    # ------------------------------------------------
    # print('-----------------------------------------------\\-----------------------------------------------')
    concatenado = automatosEquivalentes(afd, afdSecundario)
    # print(concatenado)
    # print('-----------------------------------------------\\-----------------------------------------------')
    # afdTernario = multiplicaAutomato(afd, afdSecundario)
    # print(afdTernario)
    # multiplicaAutomato(afd, afdSecundario)
    # print('automato ternario: \n\n',automatoTernario)
    # print(concatenado)
    # print("O que esperar disso aqui?:", concatenado.equivalenciaEstados())
    # print(multiplicaAutomato(afd,afdSecundario))
    # print('-----------------------------------------------\\-----------------------------------------------')
    # print(automatoIntercesao(afd,afdSecundario))
    # print('-----------------------------------------------\\-----------------------------------------------')
    # print(automatoUniao(afd,afdSecundario))
    # print(afdSecundario)
    # afd.salvaAutomato('automatoArquivo')
    # automatosEquivalentes(afd, afdSecundario)
    print(afd)
    afdterciario = afd.afdComplemento()
    print('-----------------------------------------------\\-----------------------------------------------')
    print(afdterciario)
    cadeia = 'ababbbba'
    afdSecundario.limpaAfd()
    parada = afdSecundario.move(cadeia)
    if not afdSecundario.deuErro() and afdSecundario.estadoFinal(parada):
        print('Aceita cadeia "{}"'.format(cadeia))
    else:
        print('Rejeita cadeia "{}"'.format(cadeia))
